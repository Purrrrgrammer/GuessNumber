SRP 
    Каждый класс имеет только одну зону ответственности:
    * Game - содержит только игровую логику
    * InMemoryGameRepository - отвечает за хранение и создание игр
    * GameService - управляет процессом игры через State Pattern
    * GameStateFactory - создает состояния игры
    * конкретный GameState - обрабатывает соответствующее состояние игры
    * ConsoleUserOutputService - отвечает только за вывод сообщений пользователю
    * ConsoleUserInputService - отвечает только за ввод пользователя
    * NumberValidator - Валидация числового ввода
    и т.д.
OCP
    * Сервисы ввода/вывода: Для перехода на графический интерфейс достаточно создать новые реализации 
      IUserInputService/IUserOutputService
    * Репозиторий. Нужно добавить новую реализацию IGameRepository и использовать
    * (частично) Реализован паттерн "Состояние". При добавлении нового состояния, нужно: 
        1. Cоздать новый класс, реализующий IGameState и метод в фабрике. 
        2. Добавить метод в IGameStateFactory
      Код уже существующих состояний не меняется, если не требуется новый переход из них.
      Например из AttemptState в новое состояние HintState. Можно было бы исправить внедрением таблицы переходов
LSP
    * Все (WelcomeState, AttemptState, WinState, LoseState) взаимозаменяемы через IGameState.
      Каждое состояние корректно реализует контракт Handle()
    * Реализована иерархия классов ввода UserInput с наследниками NumberUserInput, ConfirmationUserInput. 
      Можно безопасно заменять типы ввода в клиентском коде (наследники не усиливают предусловия и не ослабляют постусловия)
ISP
    Интерфейсы узкие и специализированные. 
    * IGameState содержит метод обработки состояния игры
    * IGameStateFactory - 4 метода создания различных состояний
    * IGameRepository содержит только методы работы с хранилищем игр
    * IUserInputService - обработка ввода пользователя
    * IUserOutputService - вывод пользователю
    и т.д.
DIP
    * Все зависимости передаются через конструкторы
      Зависимости от абстракций (интерфейсы) 
    * Компоновка зависимостей происходит в точке входа (Program.cs). 
      В приложении Web API можно использовать DI-контейнер
      


